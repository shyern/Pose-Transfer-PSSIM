import numpy as np
import sys
# sys.path.append('/home/haoyue/codes/ssd/caffe/python')
sys.path.append('/home/haoyue/zfs/caffe-mz/caffe/python')
##Caffe from ssd branc
import caffe

from skimage import img_as_float
from tqdm import tqdm
from PIL import Image

class SSDScorer(object):
    def __init__(self, gpu_id=0, model_def='/home/haoyue/codes/Pose-Transfer-V2/ssd_score/deploy.prototxt', model_weights='/data0/haoyue/codes/PATN/auxiliary_files/ssd_models/VGGNet/VOC0712/SSD_300x300/VGG_VOC0712_SSD_300x300_iter_120000.caffemodel'):
        caffe.set_device(gpu_id)
        caffe.set_mode_gpu()
        self.net = caffe.Net(model_def, model_weights, caffe.TEST)

        # input preprocessing: 'data' is the name of the input blob == net.inputs[0]
        self.transformer = caffe.io.Transformer({'data': self.net.blobs['data'].data.shape})
        self.transformer.set_transpose('data', (2, 0, 1))
        self.transformer.set_mean('data', np.array([104,117,123])) # mean pixel
        self.transformer.set_raw_scale('data', 255)  # the reference model operates on images in [0,255]
        self.transformer.set_channel_swap('data', (2,1,0))  # the reference model has channels in BGR order

        # set net to batch size of 1
        self.img_side = 300
        self.net.blobs['data'].reshape(1,3,self.img_side,self.img_side)

    def get_score(self, image, image_class):
        image = img_as_float(image)
        transformed_image = self.transformer.preprocess('data', image)
        self.net.blobs['data'].data[...] = transformed_image

        detections = self.net.forward()['detection_out']

        det_label = detections[0,0,:,1]
        det_conf = detections[0,0,:,2]
        top_indices = [i for i, label in enumerate(det_label) if label == image_class]
        score = 0 if len(top_indices) == 0 else max(det_conf[top_indices])
        return score

    def get_score_image_set(self, imgs, image_class=15):
        #image_class=15 Only persons
        scores = []
        for img in tqdm(imgs):
            scores.append(self.get_score(img, image_class))
        return np.mean(scores)

if __name__ == "__main__":
    from skimage.io import imread
    import os
    from argparse import ArgumentParser

    split = lambda s: tuple(map(int, s.split(',')))
    parser = ArgumentParser(description="Computing ssd_score")
    # market
    parser.add_argument("--image_size", default=(128,64), type=split, help='Image size')
    parser.add_argument("--input_dir", default='/home/haoyue/remote/Person-Image-Gen-pssim/results/results_market/PATN/test_latest/images', help='Folder with images')
    parser.add_argument("--img_index", default=4, type=int,  help='Index of image generated image '
                                                                  'for results with multiple images')
    parser.add_argument("--gpu_id", default=0, type=int, help='GPU ID')

    args = parser.parse_args()
    print (args)

    imgs = []
    for name in os.listdir(args.input_dir):
        img = imread(os.path.join(args.input_dir, name))
        img = img[:, args.img_index * args.image_size[1]:(args.img_index + 1) * args.image_size[1]]
        imgs.append(img)

        # img = imread(os.path.join(args.input_dir, name))
        # for PATN market
        # img = img[:,256:320,:]  #img.crop((256, 0, 320, 128))

        # for Def-GAN
        # img = img[:,128:192,:]
        # img = img[:, 512:768, :]
        # for GFLA
        # img = img

        # ???
        # img = img[:, args.img_index * args.image_size[1]:(args.img_index + 1) * args.image_size[1]]
        # imgs.append(img)

    print('load images')
    sc = SSDScorer(args.gpu_id)
    print(args.input_dir)
    print('DS', sc.get_score_image_set(imgs))
